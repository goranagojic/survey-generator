import regex as re

from random import randint
from pathlib import Path
from string import Template

from model.survey import *
from model.question import *
from utils.database import session
from utils.logger import logger
from utils.tools import fisher_yates_shuffle


class SurveyGenerator:

    supported_export_types = ["html", "json"]

    def generate_all(self, n_surveys=None):
        """
        Generates surveys and saves them to the database.

        Surveys are generated by image group - each survey contain all questions generated for one image group.

        :param n_surveys: Maximum number of survey that should be generated. If the requested number is larger then
            a possible number of surveys that can be generated, the method generate as many surveys as it can.
        :return:
        """
        print("generator 2")

        current_image_group = Images.get_min_image_group()
        max_image_group = Images.get_max_image_group()

        # iterate while there are more question groups to include in the survey
        while current_image_group <= max_image_group:

            questions = Questions.get_by_image_group(gid=current_image_group, unassigned=True)
            # print(f">>> Dobavio pitanja za grupu {current_image_group}.")
            if questions is None or len(questions) == 0:
                logger.info(f"All questions assigned with group id {current_image_group} are already assigned to an "
                            f"existing survey. Skipping.")
                current_image_group += 1
                continue

            # save a survey to database so that it is assigned valid id
            current_image_group += 1
            survey = RegularSurvey(auth_page=False)
            session.add(survey)
            session.commit()

            questions = fisher_yates_shuffle(questions)

            for i in range(0, len(questions)):
                question = questions[i]
                survey.questions.append(question)
                logger.info(f"Added question {question.id} to survey {survey.id}.")

            # generate survey json and update the survey in the database
            survey.generate()

            # replace survey id placeholders in questions associated to survey with the survey id
            survey.json = re.sub("^_^", str(survey.id), survey.json)
            session.commit()

            # stop survey generation if required number of surveys is reached
            if n_surveys is not None:
                n_surveys -= 1
                if n_surveys == 0:
                    break

    @staticmethod
    def export_surveys(where, export_type="json", survey_type="regular"):
        """

        :param where:
        :param export_type:
        :param survey_type:
        :return:
        """
        # check if directory to export to is ok
        if where is not None:
            if not Path(where).is_dir():
                logger.error(f"Cannot export surveys to {where} because it is not a directory.")
                raise NotADirectoryError(f"Cannot export surveys to {where} because it is not a directory.")
            else:
                logger.info(f"Survey export is enabled. You can find exported surveys in directory '{where}'.")

        # check if export type is valid
        export_type = export_type.lower()
        if export_type not in SurveyGenerator.supported_export_types:
            logger.error(f"Cannot export survey to '{export_type}'. Supported types are "
                         f"{SurveyGenerator.supported_export_types}")
            raise ValueError(f"Cannot export survey to '{export_type}'. Supported types are "
                             f"{SurveyGenerator.supported_export_types}")

        # export content
        surveys = session.query(Survey).where(Survey.type == survey_type).all()
        if len(surveys) == 0:
            logger.warning(f"There are no surveys in a database to be exported. Skipping.")
            exit(1)

        for survey in surveys:
            if type(survey) == RegularSurvey:
                prefix = "regular"
            else:
                prefix = "control"
            if export_type == "json":
                survey_filename = f"{prefix}-survey-{survey.id}.t2.json"
                target_path = Path(where) / survey_filename
                with open(target_path, "w") as fout:
                    fout.write(survey.json)
                    logger.info(f"Survey {survey_filename} saved!")
            else:  # html
                # $head - html head section
                # $body - html body section
                html = Template("""
<html>
                    $head
                    $body
</html>
                """).substitute({
                    "head": SurveyGenerator._generate_html_head_template(),
                    "body": SurveyGenerator._genenerate_html_body_template().substitute({
                        "survey_json": survey.json,
                        "jqueryselector": "$"
                    })
                })
                survey_filename = f"{prefix}-survey-{survey.id}.t2.html"
                target_path = Path(where) / survey_filename
                with open(target_path, "w") as fout:
                    fout.write(html)
                    logger.info(f"Survey {survey_filename} saved!")

    @staticmethod
    def _generate_html_head_template():
        return """ 
  <head> 
    <meta charset="UTF-8">

    <!-- favicon settings --> 
    <link rel="apple-touch-icon" sizes="180x180" href="apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="favicon-16x16.png">
    <link rel="manifest" href="site.webmanifest">
    <link rel="mask-icon" href="safari-pinned-tab.svg" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="theme-color" content="#ffffff">
    
    <!-- jquery and survey.jquery -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.1.1/jquery.min.js"></script>
    <link href="https://unpkg.com/survey-jquery@1.8.56/modern.css" type="text/css" rel="stylesheet" />
    <script src="https://unpkg.com/survey-jquery@1.8.56/survey.jquery.min.js"></script>
    
    <script>
      let DoctorData = {
         //PHP-DOCTOR-DATA-REPLACE
      };
      let SurveyData = {
         //PHP-SURVEY-DATA-REPLACE
      };
     </script>
  </head>
"""

    @staticmethod
    def _genenerate_html_body_template():
        # $survey_json - survey json string saved in a database
        # $jqueryselector - is to be substitutes with "$" as a workaround
        return Template("""
  <body>
    <div id="surveyContainer"></div>
    
    <!-- Init survey -->
    <script>
      Survey
        .StylesManager
        .applyTheme("modern");

      Survey
        .Serializer
        .addProperty("imagepicker", "imageTag:text")
        
      var surveyJSON = $survey_json
      function sendDataToServer(sender) {
          let aid = SurveyData.id;
          let akey = SurveyData.APIKey;
          let xhr = new XMLHttpRequest();
          xhr.open("POST", "./advance.php?anketa=" + aid + "&api=" + akey);
          xhr.setRequestHeader("Content-Type", "application/json; charset=utf-8");
          xhr.send(JSON.stringify(sender.data));
      }
      var survey = new Survey.Model(surveyJSON);
      
      survey
        .onAfterRenderPanel
        .add(function (sender, options) {
            console.debug("Opaljen onAfterRenderPanel dogadjaj");
           // options.htmlElement - an HTML element bound to the panel object
           // options.panel       - a panel object for which the event is fired 
        });
        
      survey
        .onAfterRenderPage
        .add(function (sender, options) {
            console.debug("Opaljen onAfterRenderPage dogadjaj");
            // options.page - a page object for which the event is fired, typically the current/active page
            // options.htmlElement - an HTML element bound to the page object
        });
        
      survey
        .onAfterRenderQuestion
        .add(function (sender, options) {
            // options.question - a page object for which the event is fired, typically the current/active page
            // options.htmlElement - an HTML element bound to the page object
            console.debug("Opaljen onAfterRenderQuestion dogadjaj");
            if (!options.question.imageTag) return;
            if (options.question.imageTag === "original") {
                options.htmlElement.parentElement.attributes.style.value = "flex: 1; width: 100%";
            } else if (options.question.imageTag === "segmaps") {
                options.htmlElement.parentElement.attributes.style.value = "flex: 2; width: 100%";
            } else {
                console.debug("Nije ni originalni ni segmaps imagepicker")
            }
            
            let container = document.getElementsByClassName("sv-row")
            if (container.length !== 1) {
                console.debug("Iz nekog razloga postoji vise od jednog elementa sa sv-row klasom... Izlazim.");
                return;
            }
            container = container[0];
            let images = document.getElementsByTagName("img");
            let minimal_width = 300;  // Т7Т: минимална дозвољена ширина слике у пикселима.
            for (image in images) {   // Т7Т: иницијализација величина слика да би се величине слика добро рачунале за случај када могу да стану максимално 2 једна до друге.
              if (images[image].style) {
                let old_width = images[image].width;
                images[image].style.width = minimal_width;
                images[image].width = minimal_width;
                images[image].style.height = Math.floor(images[image].height*minimal_width/old_width);
                images[image].height = Math.floor(images[image].height*minimal_width/old_width);
              }
            }
            
            let container_original = container.children[0];
            let container_original_picture = container_original.children[0].children[1].children[0];  // Т7Т: најужи део у којем се ицртава оригинал слика, преузима се да не би морали да се рачунају заузећа од стране маргина, тапацирања и ивица.
            let container_segment = container.children[1];
            let container_segment_pictures = container_segment.children[0].children[1].children[0];  // Т7Т: најужи део у којем се ицртавају сегментационе слике, преузима се да не би морали да се рачунају заузећа од стране маргина, тапацирања и ивица.

            let new_width = -1;
            if (Math.floor(container.offsetWidth) < 675) {  // Т7Т: ако укупна ширина доступна за приказ питања није барем 675, рачунамо да не могу стати ни 2 слике како треба једна до друге, па стављамо величину те једне видљиве слике на максималну доступну, а минимално 500. -->
              new_width = Math.floor(container_original_picture.offsetWidth-8); 
              if (new_width < 500)
                new_width = 500;
            } else if (Math.floor(container.offsetWidth) < 1000) {  // Т7Т: ако укупна ширина доступна за приказ питања није барем 950, рачунамо да не могу стати све 3 слике ако су ширине слика веће од 300 пиксела па их стављамо на максималну доступну ширину за 2 слике.
              new_width = Math.floor(container_segment_pictures.offsetWidth- 32);  // Т7Т: рачунање доступног простора чисто за 1 слику у сегментационом делу
              new_width = new_width + Math.floor(container_original_picture.offsetWidth-8); // Т7Т: додавање на ширину за 1 сегментациону слику и доступну ширину за оригинал
              new_width = Math.floor(new_width/2); // Т7Т: рачунање ширине за појединачну слику (у овој верзији све слике су исте ширине (ако су истог односа онда су и исте висине))
            } else {
              new_width = Math.floor(container_segment_pictures.offsetWidth-Math.ceil(container_segment.offsetWidth*0.05) - 32); // Т7Т: рачунање доступног простора чисто за 2 слике у сегментационом делу
              new_width = new_width + Math.floor(container_original_picture.offsetWidth-8); // Т7Т: додавање на ширину за 2 сегментационе слике и доступну ширину за оригинал
              new_width = Math.floor(new_width/3); // Т7Т: рачунање ширине за појединачну слику (у овој верзији све слике су исте ширине (ако су истог односа онда су и исте висине))
            }
            if (new_width < minimal_width) // Т7Т: провера смислености; апсолутни дозвољени минимум за ширину слике у анкети; ако је срачуната величина за слику мања од минималне ширине у пикселима поставља се на минималну ширину у пискелима. -->
              new_width = minimal_width;
            for (image in images) {
                if (images[image].style) {
                  let old_width = images[image].width;
                  images[image].style.width = new_width;
                  images[image].width = new_width;
                  images[image].style.height = Math.floor(images[image].height*new_width/old_width);
                  images[image].height = Math.floor(images[image].height*new_width/old_width);
                }
            }
            
            // dodavanje vertikalnih razmaka iznad i ispod opisa
            description = document.getElementsByClassName("sv-description")[0].children[0]
            description.style = "position: absolute; margin-top: 5px; margin-bottom: 10px;"
            
        });
        
      survey.locale = "rs"
      
      $jqueryselector("#surveyContainer").Survey({
          model: survey,
          onComplete: sendDataToServer
      });
    </script>
  </body>
""")


